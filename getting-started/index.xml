<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Getting Started on Orbit</title>
    <link>/orbit/getting-started/</link>
    <description>Recent content in Getting Started on Orbit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/orbit/getting-started/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Prerequisites</title>
      <link>/orbit/getting-started/prerequisites/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/orbit/getting-started/prerequisites/</guid>
      <description>Required Software The minimum requirements for an Orbit client application.
 Java 11 SE SDK or above. Gradle Kotlin  Orbit Server To run an Orbit Server inside a Docker environment
 Docker Desktop Docker Compose  Recommended Software  IntelliJ IDEA is our preferred IDE.  </description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>/orbit/getting-started/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/orbit/getting-started/hello-world/</guid>
      <description>In this guide we’ll cover how to get a very simple Orbit application running in the form of “Hello World”. It shows using a single-module in a single-process environment, often useful for development purposes. This will demonstrate how to set up an Actor and communicate with an Orbit Server.
This tutorial assumes that you have set up a development environment as described in the Getting Started Prerequisites document and have some familiarity with Gradle based Kotlin projects.</description>
    </item>
    
    <item>
      <title>Modules</title>
      <link>/orbit/getting-started/modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/orbit/getting-started/modules/</guid>
      <description>The Orbit project is split into several modules for client and server.
Client orbit-client A JVM library for applications interfacing with an Orbit cluster. It handles maintaining a connection to the mesh, leasing addressables, and routing messages. It will be the main entrypoint for most developers.
To include in your Gradle project, import the client library.
implementation(&amp;#34;cloud.orbit:orbit-client:2.0.0-alpha.67&amp;#34;) Server Orbit can be run as a packaged service without having to delve into the server modules.</description>
    </item>
    
    <item>
      <title>Addressables</title>
      <link>/orbit/getting-started/addressables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/orbit/getting-started/addressables/</guid>
      <description>In Orbit, an addressable is an object that interacts with the world through asynchronous messages. Simply, it has an address and can receive messages, even remotely.
Orbit will activate an addressable when it receives a message, and deactivate it when after a configurable period of inactivity. This patterns allows developers to speed up interactions and reduce load on databases and external services.
Orbit guarantees that only one addressable with a given identity can be active at any time in the cluster.</description>
    </item>
    
    <item>
      <title>Actors</title>
      <link>/orbit/getting-started/actors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/orbit/getting-started/actors/</guid>
      <description>Actors are the most common form of addressable and are suitable for most situations. The distinction is semantic and Actor interfaces are provided to facilitate the actor pattern.
Actors are never created or destroyed; they always exist conceptually. Not all actors in Orbit will be in-memory in the cluster at a given time. Actors which are in-memory are considered “activated” and those which are not are “deactivated”. The process of an actor being created in-memory is known as “Activation” and the process of an actor being removed from memory is known as “Deactivation”.</description>
    </item>
    
    <item>
      <title>Migration from Orbit 1.x</title>
      <link>/orbit/getting-started/migration-from-1.x/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/orbit/getting-started/migration-from-1.x/</guid>
      <description>Orbit 2 Philosophy Orbit 2 accomplishes the same basic goals as Orbit 1.x, but via a whole different approach. Orbit 1.x takes the form of a component included in an application utilizing distributed storage to coordinate messaging between service instances. Orbit 2 has taken all the responsibilities of tracking Actors and routing messaging into a standalone, scalable, and multi-tenant mesh service. Applications connect to the mesh over GRPC through a thin client library that manages the connection, leasing, and message delivery.</description>
    </item>
    
  </channel>
</rss>